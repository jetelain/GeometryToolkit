<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Definitions.tt" #>
<#@ output extension=".cs" #>
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace Pmad.Geometry
{
<#
	foreach(var def in definitions.Where(d => d.IsFP))
	{
#>
    <#=def.Visibility#> struct Matrix2x<#=def.Suffix#> : IMatrix2x2<<#=def.Primitive#>, <#=def.Struct#>, Matrix2x<#=def.Suffix#>>
    {
        public readonly <#=def.Struct#> X;
        public readonly <#=def.Struct#> Y;

        public <#=def.Primitive#> M11 => X.X;

        public <#=def.Primitive#> M12 => X.Y;

        public <#=def.Primitive#> M21 => Y.X;

        public <#=def.Primitive#> M22 => Y.Y;

        public Matrix2x<#=def.Suffix#>(<#=def.Struct#> x, <#=def.Struct#> y)
        {
            X = x; 
            Y = y;
        }

        public static Matrix2x<#=def.Suffix#> CreateRotation(<#=def.Primitive#> radians)
        {
            //var cos = <#=def.Math#>.Cos(radians);
            //var sin = <#=def.Math#>.Sin(radians); 
            (var sin, var cos) = MatrixHelper.SinCos(radians);
            return new Matrix2x<#=def.Suffix#>(new(cos, sin), new(-sin, cos));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=def.Struct#> Transform(<#=def.Struct#> value)
        {
            return (X * value.X) + (Y * value.Y);
        }

        public bool Equals(Matrix2x<#=def.Suffix#> other)
        {
            return other.X.Equals(X) && other.Y.Equals(Y);
        }

        public override bool Equals([NotNullWhen(true)] object? obj)
        {
            if (obj is Matrix2x<#=def.Suffix#> other)
            {
                return Equals(other);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(X.GetHashCode(), Y.GetHashCode());
        }
    }

    <#=def.Visibility#> struct Matrix3x<#=def.Suffix#> : IMatrix3x2<<#=def.Primitive#>, <#=def.Struct#>, Matrix3x<#=def.Suffix#>>
    {
        public readonly Matrix2x<#=def.Suffix#> XY;

        public readonly <#=def.Struct#> Z;

        public <#=def.Primitive#> M11 => XY.M11;

        public <#=def.Primitive#> M12 => XY.M12;

        public <#=def.Primitive#> M21 => XY.M21;

        public <#=def.Primitive#> M22 => XY.M22;

        public <#=def.Primitive#> M31 => Z.X;

        public <#=def.Primitive#> M32 => Z.Y;

        public Matrix3x<#=def.Suffix#>(Matrix2x<#=def.Suffix#> xy, <#=def.Struct#> z)
        {
            XY = xy; 
            Z = z;
        }

        public static Matrix3x<#=def.Suffix#> CreateRotation(<#=def.Primitive#> radians, <#=def.Struct#> centerPoint)
        {
            //var cos = <#=def.Math#>.Cos(radians);
            //var sin = <#=def.Math#>.Sin(radians);
            (var sin, var cos) = MatrixHelper.SinCos(radians);

            var z = new Matrix2x<#=def.Suffix#>(new (1 - cos, sin),new(-sin, 1 - cos))
                .Transform(centerPoint);

            return new (new (new (cos, sin), new(-sin, cos)), z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=def.Struct#> Transform(<#=def.Struct#> value)
        {
            return XY.Transform(value) + Z;
        }

        public bool Equals(Matrix3x<#=def.Suffix#> other)
        {
            return other.XY.Equals(XY) && other.Z.Equals(Z);
        }

        public override bool Equals([NotNullWhen(true)] object? obj)
        {
            if (obj is Matrix3x<#=def.Suffix#> other)
            {
                return Equals(other);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(XY.GetHashCode(), Z.GetHashCode());
        }
    }


<#
	}
#>
}
