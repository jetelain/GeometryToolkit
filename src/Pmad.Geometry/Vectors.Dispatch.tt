<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Definitions.tt" #>
<#@ output extension=".cs" #>
using System.Runtime.CompilerServices;

namespace Pmad.Geometry
{
    public static partial class Vectors
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TVector Create<TPrimitive,TVector>(TPrimitive x, TPrimitive y)
            where TVector : struct, IVector<TVector>, IVector2<TPrimitive,TVector>
            where TPrimitive : unmanaged
        {
<# foreach(var def in definitions) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return (TVector)(object)new <#=def.Struct#>((<#=def.Primitive#>)(object)x, (<#=def.Primitive#>)(object)y);
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TVector Create<TPrimitive,TVector>(int x, int y)
            where TVector : struct, IVector<TVector>, IVector2<TPrimitive,TVector>
            where TPrimitive : unmanaged
        {
<# foreach(var def in definitions) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return (TVector)(object)new <#=def.Struct#>(x, y);
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TVector Create<TPrimitive,TVector>(long x, long y)
            where TVector : struct, IVector<TVector>, IVector2<TPrimitive,TVector>
            where TPrimitive : unmanaged
        {
<# foreach(var def in definitions) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return (TVector)(object)new <#=def.Struct#>((<#=def.Primitive#>)x, (<#=def.Primitive#>)y);
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TVector Create<TPrimitive,TVector>(double x, double y)
            where TVector : struct, IVector<TVector>, IVector2<TPrimitive,TVector>, IVectorFP<TPrimitive,TVector>
            where TPrimitive : unmanaged
        {
<# foreach(var def in definitions.Where(d=>d.IsFP)) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return (TVector)(object)new <#=def.Struct#>((<#=def.Primitive#>)x, (<#=def.Primitive#>)y);
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }


<# foreach(var op in new[]{
    (Operator :"+", Name: "Add"),
    (Operator :"-", Name: "Substract"),
    (Operator :"/", Name: "Divide"),
    (Operator :"*", Name: "Multiply")
}) { #>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TVector <#=op.Name#><TVector>(TVector left, TVector right)
            where TVector : struct, IVector<TVector>
        {
<# foreach(var def in definitions) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return (TVector)(object)(((<#=def.Struct#>)(object)left) <#=op.Operator#> ((<#=def.Struct#>)(object)right));
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }
<# } #>

<# foreach(var op in new[]{
    (Operator :"==", Name: "Equals"),
    (Operator :"!=", Name: "NotEquals")
}) { #>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool <#=op.Name#><TVector>(TVector left, TVector right)
            where TVector : struct, IVector<TVector>
        {
<# foreach(var def in definitions) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return (((<#=def.Struct#>)(object)left) <#=op.Operator#> ((<#=def.Struct#>)(object)right));
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }
<# } #>

<# foreach(var op in new[]{
    (Operator :"/", Name: "Divide"),
    (Operator :"*", Name: "Multiply")
}) { #>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TVector <#=op.Name#><TVector,TPrimitive>(TVector left, TPrimitive right)
            where TVector : struct, IVector<TVector>, IVector2<TPrimitive,TVector>
            where TPrimitive : unmanaged
        {
<# foreach(var def in definitions) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return (TVector)(object)(((<#=def.Struct#>)(object)left) <#=op.Operator#> ((<#=def.Primitive#>)(object)right));
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TVector <#=op.Name#><TVector>(TVector left, int right)
            where TVector : struct, IVector<TVector>
        {
<# foreach(var def in definitions) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return (TVector)(object)(((<#=def.Struct#>)(object)left) <#=op.Operator#> right);
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }

<# } #>

<# foreach(var method in new[]{
"Min", "Max"
}) { #>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TVector <#=method#><TVector>(TVector left, TVector right)
            where TVector : struct, IVector<TVector>
        {
<# foreach(var def in definitions) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return (TVector)(object)<#=def.Struct#>.<#=method#>((<#=def.Struct#>)(object)left,(<#=def.Struct#>)(object)right);
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }
<# } #>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double CrossProductD<TVector>(TVector left, TVector right)
            where TVector : struct, IVector<TVector>
        {
<# foreach(var def in definitions) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return <#=def.Struct#>.CrossProduct((<#=def.Struct#>)(object)left,(<#=def.Struct#>)(object)right);
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPrimitive Dot<TPrimitive,TVector>(TVector left, TVector right)
            where TVector : struct, IVector<TVector>, IVectorFP<TPrimitive,TVector>
            where TPrimitive : unmanaged
        {
<# foreach(var def in definitions.Where(d => d.IsFP)) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return (TPrimitive)(object)<#=def.Struct#>.Dot((<#=def.Struct#>)(object)left,(<#=def.Struct#>)(object)right);
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double DotD<TPrimitive,TVector>(TVector left, TVector right)
            where TVector : struct, IVector<TVector>, IVectorFP<TPrimitive,TVector>
            where TPrimitive : unmanaged
        {
<# foreach(var def in definitions.Where(d => d.IsFP)) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return <#=def.Struct#>.Dot((<#=def.Struct#>)(object)left,(<#=def.Struct#>)(object)right);
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TVector Lerp<TPrimitive,TVector>(TVector left, TVector right, TPrimitive amount)
            where TVector : struct, IVector<TVector>, IVectorFP<TPrimitive,TVector>
            where TPrimitive : unmanaged
        {
<# foreach(var def in definitions.Where(d => d.IsFP)) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return (TVector)(object)<#=def.Struct#>.Lerp((<#=def.Struct#>)(object)left,(<#=def.Struct#>)(object)right,(<#=def.Primitive#>)(object)amount);
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TVector Lerp<TPrimitive,TVector>(TVector left, TVector right, double amount)
            where TVector : struct, IVector<TVector>, IVectorFP<TPrimitive,TVector>
            where TPrimitive : unmanaged
        {
<# foreach(var def in definitions.Where(d => d.IsFP)) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return (TVector)(object)<#=def.Struct#>.Lerp((<#=def.Struct#>)(object)left,(<#=def.Struct#>)(object)right,(<#=def.Primitive#>)amount);
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TVector Normalize<TPrimitive,TVector>(TVector left)
            where TVector : struct, IVector<TVector>, IVectorFP<TPrimitive,TVector>
            where TPrimitive : unmanaged
        {
<# foreach(var def in definitions.Where(d => d.IsFP)) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return (TVector)(object)<#=def.Struct#>.Normalize((<#=def.Struct#>)(object)left);
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TVector Clamp<TVector>(TVector value, TVector min, TVector max)
            where TVector : struct, IVector<TVector>
        {
<# foreach(var def in definitions) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return (TVector)(object)<#=def.Struct#>.Clamp((<#=def.Struct#>)(object)value,(<#=def.Struct#>)(object)min,(<#=def.Struct#>)(object)max);
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }
	}

}
