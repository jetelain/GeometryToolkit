<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Definitions.tt" #>
<#@ output extension=".cs" #>
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;

namespace Pmad.Geometry
{
<#
	foreach(var def in definitions.Where(d => d.BaseVector == "Vector128"))
	{
#>
    [DebuggerDisplay("({X};{Y})")]
    [StructLayout(LayoutKind.Explicit)]
	public partial struct <#=def.Struct#> : IEquatable<<#=def.Struct#>>, IVector2<<#=def.Primitive#>,<#=def.Struct#>>
	{ 
<#if (def.HasFiller) {#>
        private static readonly Vector128<int> SwapXYShuffle = Vector128.Create(1, 0, 3, 2);
<#} else {#>
        private static readonly Vector128<long> SwapXYShuffle = Vector128.Create(1L, 0L);
<#}#>
	    [FieldOffset(0)]
        private <#=def.BaseVector#><<#=def.Primitive#>> vector;

        [FieldOffset(0)]
        public <#=def.Primitive#> X;

        [FieldOffset(<#=def.PrimitiveSize#>)]
        public <#=def.Primitive#> Y;

        public static <#=def.Struct#> Zero => default;
        
        public static <#=def.Struct#> One => new (<#=def.BaseVector#><<#=def.Primitive#>>.One);

        public static <#=def.Struct#> UnitX => new (1, 0);

        public static <#=def.Struct#> UnitY => new (0, 1);

        public static <#=def.Struct#> MaxValue => new (<#=def.Primitive#>.MaxValue);

        public static <#=def.Struct#> MinValue => new (<#=def.Primitive#>.MinValue);

        public static <#=def.Struct#> Create(<#=def.Primitive#> x, <#=def.Primitive#> y) => new (x, y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=def.Struct#>(<#=def.Primitive#> x, <#=def.Primitive#> y)
        {
<#if (def.HasFiller) {#>
            vector = <#=def.BaseVector#>.Create(x, y, 0, 0);
<#} else {#>
            vector = <#=def.BaseVector#>.Create(x, y);
<#}#>
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=def.Struct#>(<#=def.Primitive#> value)
        {
            vector = <#=def.BaseVector#>.Create(value);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=def.Struct#>(<#=def.BaseVector#><<#=def.Primitive#>> vector)
        {
            this.vector = vector;
        }

        <#=def.Primitive#> IVector2<<#=def.Primitive#>, <#=def.Struct#>>.X { get => X; set => X = value; }

        <#=def.Primitive#> IVector2<<#=def.Primitive#>, <#=def.Struct#>>.Y { get => Y; set => Y = value; }

        public <#=def.BaseVector#><<#=def.Primitive#>> Vector
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            readonly get => vector;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => vector = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(<#=def.Struct#> left, <#=def.Struct#> right)
            => left.vector != right.vector;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(<#=def.Struct#> left, <#=def.Struct#> right)
            => left.vector == right.vector;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator *(<#=def.Struct#> left, <#=def.Struct#> right)
            => new (left.vector * right.vector);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator *(<#=def.Struct#> left, <#=def.Primitive#> right)
            => new (left.vector * right);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator *(<#=def.Primitive#> left, <#=def.Struct#> right)
            => new (left * right.vector);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator /(<#=def.Struct#> left, <#=def.Struct#> right)
<#if (def.HasFiller) {#>
            => new (left.vector / right.vector.WithElement(2, 1).WithElement(3, 1));
<#} else {#>
            => new (left.vector / right.vector);
<#}#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator /(<#=def.Struct#> left, <#=def.Primitive#> right)
            => new (left.vector / right);

<#if (def.Primitive != "int") {#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator /(<#=def.Struct#> left, int right)
            => new (left.vector / right);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator *(<#=def.Struct#> left, int right)
            => new (left.vector * right);
<#}#>

<#if (def.Primitive != "double") {#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator *(<#=def.Struct#> left, double right)
<#      if (def.Primitive == "float") { #>
            => new (left.vector * (float)right);
<#} else {#>
            => new((<#=def.Primitive#>)(left.X * right), (<#=def.Primitive#>)(left.Y * right));
<#}#>
<#}#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator +(<#=def.Struct#> left, <#=def.Struct#> right)
            => new (left.vector + right.vector);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator -(<#=def.Struct#> left, <#=def.Struct#> right)
            => new (left.vector - right.vector);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator -(<#=def.Struct#> value)
            => new (-value.vector);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly <#=def.Struct#> SwapXYInline()
        { 
<#if (def.HasFiller) {#>
            return new(Vector128.Shuffle(vector,Vector128.Create(1, 0, 3, 2)));
<#} else {#>
            return new(Vector128.Shuffle(vector,Vector128.Create(1L, 0L)));
<#}#>
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly <#=def.Struct#> SwapXYStatic()
        { 
            return new(Vector128.Shuffle(vector,SwapXYShuffle));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly <#=def.Struct#> SwapXY()
        { 
            return new(Y, X);
        }

        public readonly override int GetHashCode()
        {
            return vector.GetHashCode();
        }

        public readonly override bool Equals([NotNullWhen(true)] object? obj)
        {
            if (obj is <#=def.Struct#> other)
            {
                return Equals(other);
            }
            return false;
        }

        public readonly bool Equals(<#=def.Struct#> other)
        {
            return vector == other.vector;
        }

        
<#      if (def.Struct != "Vector2F" && def.Struct != "Vector2I") { #>
        public readonly Vector2F ToFloat() => new ((float)X, (float)Y);
<#      } #>

<#      if (def.Struct != "Vector2D" && def.Struct != "Vector2L") { #>
        public readonly Vector2D ToDouble() => new ((double)X, (double)Y);
<#      } #>

        public readonly override string ToString()
        {
            return FormattableString.Invariant($"({X};{Y})");
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> Max(<#=def.Struct#> value1, <#=def.Struct#> value2)
        {
            return new(<#=def.BaseVector#>.Max(value1.vector, value2.vector));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> Min(<#=def.Struct#> value1, <#=def.Struct#> value2)
        {
            return new(<#=def.BaseVector#>.Min(value1.vector, value2.vector));
        }
        
        public static <#=def.Struct#> Clamp(<#=def.Struct#> value, <#=def.Struct#> min, <#=def.Struct#> max)
        {
            return new(<#=def.BaseVector#>.Min(<#=def.BaseVector#>.Max(value.vector, min.vector), max.vector));
        }

        public readonly bool IsInRange(<#=def.Struct#> min, <#=def.Struct#> max)
        {
            // min <= vector && vector <= max
            return <#=def.BaseVector#>.LessThanOrEqualAll(min.vector, vector) && <#=def.BaseVector#>.LessThanOrEqualAll(vector, max.vector);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool IsGreaterThanOrEqualAll(<#=def.Struct#> other)
        {
            return <#=def.BaseVector#>.GreaterThanOrEqualAll(vector, other.vector);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool IsLessThanOrEqualAll(<#=def.Struct#> other)
        {
            return <#=def.BaseVector#>.LessThanOrEqualAll(vector, other.vector);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly <#=def.Struct#> IVector<<#=def.Struct#>>.Add(<#=def.Struct#> value)
        {
            return this + value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly <#=def.Struct#> IVector<<#=def.Struct#>>.Substract(<#=def.Struct#> value)
        {
            return this - value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly <#=def.Struct#> IVector<<#=def.Struct#>>.Multiply(<#=def.Struct#> value)
        {
            return this * value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly <#=def.Struct#> IVector<<#=def.Struct#>>.Multiply(double value)
        {
<#      if (def.IsFP) { #>
            return this * (<#=def.Primitive#>)value;
<#      } else { #>
            return new ((<#=def.Primitive#>)(X * value), (<#=def.Primitive#>)(Y * value));
<#      } #>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly <#=def.Struct#> IVector<<#=def.Struct#>>.Multiply(int value)
        {
            return this * value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly <#=def.Struct#> IVector<<#=def.Struct#>>.Divide(<#=def.Struct#> value)
        {
            return this / value;
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly <#=def.Struct#> IVector<<#=def.Struct#>>.Divide(int value)
        {
            return this / value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly <#=def.Struct#> IVector<<#=def.Struct#>>.Min(<#=def.Struct#> other)
        {
            return Min(this, other);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly <#=def.Struct#> IVector<<#=def.Struct#>>.Max(<#=def.Struct#> other)
        {
            return Max(this, other);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly <#=def.Struct#> IVector<<#=def.Struct#>>.Negate()
        {
            return -this;
        }

        public readonly <#=def.Struct#> Rotate90()
        {
            return SwapXY() * new <#=def.Struct#>(-1, 1);
        }
        
        public readonly <#=def.Struct#> RotateM90()
        {
            return SwapXY() * new <#=def.Struct#>(1, -1);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double CrossProductD(<#=def.Struct#> v1, <#=def.Struct#> v2) => CrossProduct(v1, v2);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.ResultType#> CrossProduct(<#=def.Struct#> pt1, <#=def.Struct#> pt2, <#=def.Struct#> pt3)
        {            
            return CrossProduct(pt2-pt1, pt3-pt2);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.ResultType#> CrossProductScalar(<#=def.Struct#> pt1, <#=def.Struct#> pt2, <#=def.Struct#> pt3)
        {            
            return ((<#=def.ResultType#>) (pt2.X - pt1.X) * (pt3.Y - pt2.Y) -
                    (<#=def.ResultType#>) (pt2.Y - pt1.Y) * (pt3.X - pt2.X));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly double Atan2D()
        {
            return Math.Atan2(Y, X);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly double AreaD()
        {
            return X * Y;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly <#=def.Struct#> IVector2<<#=def.Primitive#>,<#=def.Struct#>>.Multiply(<#=def.Primitive#> value)
        {
            return this * value;
        }

	}
<#
	}
#>
}
