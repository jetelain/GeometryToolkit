<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Definitions.tt" #>
<#@ output extension=".cs" #>
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.Intrinsics;

namespace Pmad.Geometry
{
<#
	foreach(var def in definitions.Where(d => d.BaseVector == null))
	{
#>
    [DebuggerDisplay("({X};{Y})")]
	public partial struct <#=def.Struct#> : IEquatable<<#=def.Struct#>>, IVector2<<#=def.Primitive#>,<#=def.Struct#>>
	{
        public static <#=def.Struct#> Zero => default;
        
        public static <#=def.Struct#> One => new (1);

        public static <#=def.Struct#> UnitX => new (1, 0);

        public static <#=def.Struct#> UnitY => new (0, 1);

        public static <#=def.Struct#> MaxValue => new (<#=def.Primitive#>.MaxValue);

        public static <#=def.Struct#> MinValue => new (<#=def.Primitive#>.MinValue);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=def.Struct#>(<#=def.Primitive#> x, <#=def.Primitive#> y)
        {
            X = x;
            Y = y;
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=def.Struct#>(<#=def.Primitive#> value)
        {
            X = value;
            Y = value;
        }

        public <#=def.Primitive#> X;

        public <#=def.Primitive#> Y;
        
        <#=def.Primitive#> IVector2<<#=def.Primitive#>, <#=def.Struct#>>.X { get => X; set => X = value; }
        
        <#=def.Primitive#> IVector2<<#=def.Primitive#>, <#=def.Struct#>>.Y { get => Y; set => Y = value; }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(<#=def.Struct#> left, <#=def.Struct#> right)
            => left.X != right.X || left.Y != right.Y;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(<#=def.Struct#> left, <#=def.Struct#> right)
            => left.X == right.X && left.Y == right.Y;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator *(<#=def.Struct#> left, <#=def.Struct#> right)
            => new (left.X * right.X, left.Y * right.Y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator *(<#=def.Struct#> left, <#=def.Primitive#> right)
            => new (left.X * right, left.Y * right);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator *(<#=def.Primitive#> left, <#=def.Struct#> right)
            => new (left * right.X, left * right.Y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator /(<#=def.Struct#> left, <#=def.Struct#> right)
            => new (left.X / right.X, left.Y / right.Y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator /(<#=def.Struct#> left, <#=def.Primitive#> right)
            => new (left.X / right, left.Y / right);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator +(<#=def.Struct#> left, <#=def.Struct#> right)
            => new (left.X + right.X, left.Y + right.Y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator -(<#=def.Struct#> left, <#=def.Struct#> right)
            => new (left.X - right.X, left.Y - right.Y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=def.Struct#> operator -(<#=def.Struct#> value)
            => new (-value.X, -value.Y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly <#=def.Struct#> SwapXY()
        {
            return new(Y, X);
        }

        public readonly override int GetHashCode()
        {
            return HashCode.Combine(X.GetHashCode(), Y.GetHashCode());
        }

        public readonly override bool Equals([NotNullWhen(true)] object? obj)
        {
            if (obj is <#=def.Struct#> other)
            {
                return Equals(other);
            }
            return false;
        }

        public readonly bool Equals(<#=def.Struct#> other)
        {
            return X == other.X && Y == other.Y;
        }

        public readonly Vector2F ToFloat() => new ((float)X, (float)Y);

        public readonly Vector2D ToDouble() => new ((double)X, (double)Y);

        public readonly override string ToString()
        {
            return FormattableString.Invariant($"({X};{Y})");
        }

        public static <#=def.Struct#> Max(<#=def.Struct#> value1, <#=def.Struct#> value2)
        {
            return new(Math.Max(value1.X, value2.X),Math.Max(value1.Y, value2.Y));
        }

        public static <#=def.Struct#> Min(<#=def.Struct#> value1, <#=def.Struct#> value2)
        {
            return new(Math.Min(value1.X, value2.X),Math.Min(value1.Y, value2.Y));
        }
        
        public static <#=def.Struct#> Clamp(<#=def.Struct#> value, <#=def.Struct#> min, <#=def.Struct#> max)
        {
            return new(Math.Clamp(value.X, min.X, max.X),Math.Clamp(value.Y, min.Y, max.Y));
        }

        public readonly bool IsInRange(<#=def.Struct#> min, <#=def.Struct#> max)
        {
            // min <= vector && vector <= max
            return IsGreaterThanOrEqualAll(min) && IsLessThanOrEqualAll(max);
        }

        public readonly bool IsGreaterThanOrEqualAll(<#=def.Struct#> other)
        {
            return X >= other.X && Y >= other.Y;
        }

        public readonly bool IsLessThanOrEqualAll(<#=def.Struct#> other)
        {
            return X <= other.X && Y <= other.Y;
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double CrossProduct(<#=def.Struct#> v1, <#=def.Struct#> v2)
        {
            return v2.Y * v1.X - v2.X * v1.Y;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double CrossProduct(<#=def.Struct#> pt1, <#=def.Struct#> pt2, <#=def.Struct#> pt3)
        {
            return CrossProduct(pt2-pt1, pt3-pt2);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double CrossProductScalar(<#=def.Struct#> pt1, <#=def.Struct#> pt2, <#=def.Struct#> pt3)
        {
            return ((double) (pt2.X - pt1.X) * (pt3.Y - pt2.Y) -
                    (double) (pt2.Y - pt1.Y) * (pt3.X - pt2.X));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly <#=def.Struct#> IVector<<#=def.Struct#>>.Add(<#=def.Struct#> value)
        {
            return this + value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly <#=def.Struct#> IVector<<#=def.Struct#>>.Substract(<#=def.Struct#> value)
        {
            return this - value;
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly <#=def.Struct#> IVector<<#=def.Struct#>>.Multiply(<#=def.Struct#> value)
        {
            return this * value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly <#=def.Struct#> IVector<<#=def.Struct#>>.Divide(<#=def.Struct#> value)
        {
            return this / value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly <#=def.Struct#> IVector<<#=def.Struct#>>.Min(<#=def.Struct#> other)
        {
            return Min(this, other);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly <#=def.Struct#> IVector<<#=def.Struct#>>.Max(<#=def.Struct#> other)
        {
            return Max(this, other);
        }

<#      if (def.Struct != "Vector2FS") { #>
        public readonly Vector2FS ToFloatS() => new ((float)X, (float)Y);
<#      } else { #>
        public readonly Vector2FS ToFloatS() => this;
<#      } #>

<#      if (def.Struct != "Vector2DS") { #>
        public readonly Vector2DS ToDoubleS() => new ((double)X, (double)Y);
<#      } else { #>
        public readonly Vector2DS ToDoubleS() => this;
<#      } #>

        public readonly <#=def.Struct#> Rotate90()
        {
            return new (-Y, X);
        }
        
        public readonly <#=def.Struct#> RotateM90()
        {
            return new (Y, -X);
        }
	}
<#
	}
#>
}
