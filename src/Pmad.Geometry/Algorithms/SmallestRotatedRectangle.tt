<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../Definitions.tt" #>
<#@ output extension=".cs" #>
/**********************************************************************************
* Author    :  Angus Johnson, Julien Etelain                                      *
* Copyright :  Angus Johnson 2010-2024, Julien Etelain 2024                       *
* Purpose   :  PointInPolygon for each supported vector type, to avoid conversion *
* License   :  http://www.boost.org/LICENSE_1_0.txt                               *
***********************************************************************************/
using Pmad.Geometry.Shapes;

namespace Pmad.Geometry.Algorithms
{
	public static class SmallestRotatedRectangle
	{
<#
	foreach(var def in definitions.Where(def => def.IsFP))
	{
#>
        public static RotatedRectangle<<#=def.Primitive#>,<#=def.Struct#>> Compute(ShapeSettings<<#=def.Primitive#>,<#=def.Struct#>> settings, ReadOnlySpan<<#=def.Struct#>> points)
        {
            <#=def.Struct#> resultSize = default;
            <#=def.Struct#> resultCenter = default;
            <#=def.Primitive#> resultAngle = 0;
            <#=def.Primitive#> resultArea = <#=def.Primitive#>.MaxValue;

            var a = points[points.Length - 1];

            for (var i = 0; i < points.Length; i++)
            {
                var b = points[i];

                var theta = (a - b).Atan2();

                var rotate = Matrix2x<#=def.Suffix#>.CreateRotation(-theta);

                var max = rotate.Transform(points[0] - a);
                var min = max;

                for (int j = 1; j < points.Length; j++)
                {
                    var r = rotate.Transform(points[j] - a);
                    max = <#=def.Struct#>.Max(r, max);
                    min = <#=def.Struct#>.Min(r, min);
                }
                var size = max - min;
                var area = size.Area();
                if (area < resultArea)
                {
                    resultArea = area;
                    resultSize = size;
                    resultAngle = theta;

                    var reverseRotate = Matrix2x<#=def.Suffix#>.CreateRotation(theta);
                    var resultP3 = reverseRotate.Transform(max);
                    var resultP1 = reverseRotate.Transform(min);
                    resultCenter = ((resultP3 + resultP1) / 2) + a;
                }
                a = b;
            }

            return new (settings, resultCenter, resultSize, resultAngle);
        }
<#
	}
#>
	}
}
