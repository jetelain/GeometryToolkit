<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

namespace Pmad.Geometry.Algorithms
{
<#

	var definitions = new []
	{
    	(Struct: "Vector2F", Primitive: "float"),
		(Struct: "Vector2D", Primitive: "double"),
		(Struct: "Vector2FS", Primitive: "float"),
		(Struct: "Vector2DS", Primitive: "double")
	};

	foreach(var def in definitions)
	{
#>
    public sealed class PathFollower<#=def.Struct#> : IPathFollower<<#=def.Primitive#>, <#=def.Struct#>>
    {
        private readonly IEnumerator<<#=def.Struct#>> enumerator;
        private <#=def.Struct#> previousPoint;
        private <#=def.Struct#> point;
        private <#=def.Struct#> previousPosition;
        private <#=def.Struct#> position;
        private <#=def.Struct#> delta;
        private <#=def.Primitive#> length;
        private <#=def.Primitive#> positionOnSegment;
        private bool hasReachedEnd;
        private int index;

        public PathFollower<#=def.Struct#>(IEnumerable<<#=def.Struct#>> points, bool keepRightAngles = false)
        {
            enumerator = points.GetEnumerator();
            index = 0;
            KeepRightAngles = keepRightAngles;
            Init();
        }

        public void Reset()
        {
            enumerator.Reset();
            index = 0;
            Init();
        }

        private void Init()
        {
            IsAfterRightAngle = false;
            previousPosition = default;
            length = default;
            positionOnSegment = default;
            previousPoint = default;
            if (enumerator.MoveNext())
            {
                position = point = enumerator.Current;
                delta = default;
                hasReachedEnd = false;
                MoveNextPoint();
            }
            else
            {
                hasReachedEnd = true;
            }
        }

        private bool MoveNextPoint()
        {
            previousPoint = point;
            if (!enumerator.MoveNext())
            {
                point = default;
                length = default;
                positionOnSegment = default;
                return false;
            }
            index++;
            point = enumerator.Current;
            delta = point - previousPoint;
            length = delta.Length();
            positionOnSegment = default;
            return true;
        }

        public <#=def.Struct#> Current => position;

        public <#=def.Struct#> Previous => previousPosition;

        public <#=def.Struct#> Vector => <#=def.Struct#>.Normalize(delta);

        public bool KeepRightAngles { get; }

        public bool IsAfterRightAngle { get; private set; }

        public bool IsLast => hasReachedEnd;

        public bool IsFirst => index <= 1;

        /// <summary>
        /// Index in original list
        /// </summary>
        public int Index => index;

        public bool Move(<#=def.Primitive#> step)
        {
            if (IsAfterRightAngle)
            {
                index++;
            }
            IsAfterRightAngle = false;
            if (hasReachedEnd)
            {
                return false;
            }
            var remainLength = step;
            while (remainLength + positionOnSegment > length)
            {
                remainLength -= length - positionOnSegment;
                var previousDelta = delta;
                if (!MoveNextPoint())
                {
                    hasReachedEnd = true;
                    if (position != previousPoint)
                    {
                        previousPosition = position;
                        position = previousPoint;
                        return true;
                    }
                    return false;
                }
                if (KeepRightAngles)
                {
                    var angle = Math.Abs(Math.Abs(Math.Acos(<#=def.Struct#>.Dot(<#=def.Struct#>.Normalize(delta), <#=def.Struct#>.Normalize(previousDelta)))) - (Math.PI / 2));
                    if (angle < 0.1d && position != previousPoint)
                    {
                        index--;
                        previousPosition = position;
                        position = previousPoint;
                        positionOnSegment = 0;
                        IsAfterRightAngle = true;
                        return true;
                    }
                }
            }
            positionOnSegment += remainLength;
            previousPosition = position;
            position = <#=def.Struct#>.Lerp(previousPoint, point, positionOnSegment / length);
            return true;
        }
    }
<#
	}
#>
}
