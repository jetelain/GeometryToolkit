<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../Definitions.tt" #>
<#@ output extension=".cs" #>
using System.Runtime.CompilerServices;
using Clipper2Lib;
using Pmad.Geometry.Collections;
using Pmad.Geometry.Shapes;

namespace Pmad.Geometry.Algorithms
{
    public static class AlgorithmsDispatcher
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static PointInPolygonResult TestPointInPolygon<TVector>(this ReadOnlyArray<TVector> points, TVector pt)
            where TVector : struct, IVector<TVector>
        {
<# foreach(var def in definitions) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return ((ReadOnlyArray<<#=def.Struct#>>)(object)points).TestPointInPolygon((<#=def.Struct#>)(object)pt);
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }

	    [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static PointInPolygonResult TestPointInPolygon<TVector>(this IReadOnlyList<TVector> points, TVector pt)
            where TVector : struct, IVector<TVector>
        {
<# foreach(var def in definitions) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return ((IReadOnlyList<<#=def.Struct#>>)(object)points).TestPointInPolygon((<#=def.Struct#>)(object)pt);
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }

	    [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static PointInPolygonResult TestPointInPolygon<TVector>(this List<TVector> points, TVector pt)
            where TVector : struct, IVector<TVector>
        {
<# foreach(var def in definitions) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return ((List<<#=def.Struct#>>)(object)points).TestPointInPolygon((<#=def.Struct#>)(object)pt);
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }

	    [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetSignedAreaD<TVector>(this ReadOnlyArray<TVector> points)
            where TVector : struct, IVector<TVector>
        {
<# foreach(var def in definitions) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return ((ReadOnlyArray<<#=def.Struct#>>)(object)points).GetSignedArea();
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }

	    [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetSignedAreaD<TVector>(this IReadOnlyList<TVector> points)
            where TVector : struct, IVector<TVector>
        {
<# foreach(var def in definitions) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return ((IReadOnlyList<<#=def.Struct#>>)(object)points).GetSignedArea();
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }

	    [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float GetSignedAreaF<TVector>(this ReadOnlyArray<TVector> points)
            where TVector : struct, IVector<TVector>
        {
<# foreach(var def in definitions) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return (float)((ReadOnlyArray<<#=def.Struct#>>)(object)points).GetSignedArea();
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }

	    [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float GetSignedAreaF<TVector>(this IReadOnlyList<TVector> points)
            where TVector : struct, IVector<TVector>
        {
<# foreach(var def in definitions) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return (float)((IReadOnlyList<<#=def.Struct#>>)(object)points).GetSignedArea();
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }

	    [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static RotatedRectangle<TPrimitive, TVector> GetSmallestRotatedRectangleContaining<TPrimitive,TVector>(ShapeSettings<TPrimitive, TVector> settings, ReadOnlyArray<TVector> points)
            where TPrimitive : unmanaged
            where TVector : struct, IVector2<TPrimitive, TVector>, IVectorFP<TPrimitive, TVector>
        {
<# foreach(var def in definitions.Where(def => def.IsFP)) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return (RotatedRectangle<TPrimitive, TVector>)(object)SmallestRotatedRectangle.Compute((ShapeSettings<<#=def.Primitive#>,<#=def.Struct#>>)(object)settings, ((ReadOnlyArray<<#=def.Struct#>>)(object)points).AsSpan());
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }

        
	    [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Circle<TPrimitive, TVector> GetCircleFromThreePoints<TPrimitive,TVector>(ShapeSettings<TPrimitive, TVector> settings, TVector a, TVector b, TVector c)
            where TPrimitive : unmanaged
            where TVector : struct, IVector2<TPrimitive, TVector>, IVectorFP<TPrimitive, TVector>
        {
<# foreach(var def in definitions.Where(def => def.IsFP)) { #>
            if (typeof(TVector) == typeof(<#=def.Struct#>))
            {
                return (Circle<TPrimitive, TVector>)(object)CircleFromThreePoints.Compute((ShapeSettings<<#=def.Primitive#>,<#=def.Struct#>>)(object)settings, (<#=def.Struct#>)(object)a, (<#=def.Struct#>)(object)b, (<#=def.Struct#>)(object)c);
            }
<# } #>
            ThrowHelper.ThrowNotSupportedException();
            return default;
        }

	}
}
